---
title: Homework 3
layout: default
---
# Homework 3

This lab was simply to become familiar with C# by converting a simple calculator coded in Java to C#. 


[Assignment Page](http://www.wou.edu/~morses/classes/cs46x/assignments/HW3.html)

[Calculator in C#](https://github.com/Hindelburg/Website1/tree/master/Calculator)

##	Step 1: Getting Visual Studio 2017

I thought about skipping this step in this document because I already have Visual Studio 2017 on this 
computer. It took me a bit to get familiar with it again, but I didn't have to set up the enviorment again.

## Step 2: Translating to C#

### Class 1
The first step I took in translating the calculator was starting at the largest/primary class, calculator.
So I opened it in Visual Studios along side a new C# project. Here's the Java code for the start of the class
and the main method. 

```java
public class Calculator
{
	/**
	 *  Our data structure, used to hold operands for the postfix calculation.
	 */
	private StackADT stack = new LinkedStack();

	/** Scanner to get input from the user from the command line. */
	private Scanner scin = new Scanner( System.in );

	/**
	 *  Entry point method. Disregards any command line arguments.
	 *
	 *@param  args  The command line arguments
	 */
	public static void main( String[] args )
	{
		// Instantiate a "Main" object so we don't have to make everything static
		Calculator app = new Calculator();
		boolean playAgain = true;
		System.out.println("\nPostfix Calculator. Recognizes these operators: + - * /");
		while( playAgain )
		{
			playAgain = app.doCalculation();
		}
		System.out.println("Bye.");
	}
```

My first step was adding a namespace, calculator, and putting the class in that. I did that with all
classes in this project. The "using" statements were automatically generated by Visual Studio. The only other
real conversions I had to do was changing the "boolean" values to "bool" and the System.out.println()
with Console.WriteLine(). I also capitalized the first letter of the methods and method calls.

```c#

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Calculator
{
    class Calculator
    {
        private IStackADT stack = new LinkedStack();
        static void Main(string[] args)
        {
            Calculator app = new Calculator();
            bool playAgain = true;
            Console.WriteLine("\nPostfix Calculator. Recognizes these operators: + - * /");
            while(playAgain)
            {
                playAgain = app.DoCalculation();
            }
            Console.WriteLine("Bye.");
        }

```

This is the original Java version of the second method, doCalculation(). I mostly just had to
replace the print statements, the scan statements, and the string comparisions. I also changed
the exception types to ArguementExceptions, which I found to be about the C# Equivalent. 


```java
/**
*  Get input string from user and perform calculation, returning true when
*  finished. If the user wishes to quit this method returns false.
*
*@return    true if a calculation succeeded, false if the user wishes to quit
*/
private boolean doCalculation()
{
	System.out.println("Please enter q to quit\n");
	String input = "2 2 +";
	System.out.print("> ");			// prompt user
	
	input = scin.nextLine();		
	// looks like nextLine() blocks for input when used on an InputStream (System.in).  Docs don't say that!
		
	// See if the user wishes to quit
	if( input.startsWith( "q" ) || input.startsWith( "Q" ) )
	{
		return false;
	}
	// Go ahead with calculation
	String output = "4";
	try
	{
		output = evaluatePostFixInput( input );
	}
	catch( IllegalArgumentException e )
	{
		output = e.getMessage();
	}
	System.out.println("\n\t>>> " + input + " = " + output);
	return true;
}
```

As you can see below, this method required very little modifications to change it to C#. 


```c#
bool DoCalculation()
{
    Console.WriteLine("Please enter Q to quit\n");
    string input = "2 2 + ";
    Console.Write("> ");

    input = Console.ReadLine();

    if(input[0] == 'q' || input[0] == 'Q')
    {
        return false;
    }
    string output = "4";
    try
    {
        output = EvaluatePostFixInput(input);
    }
    catch(ArgumentException e)
    {
        output = e.Message;
    }
    Console.WriteLine("\n\t>>> " + input + " = " + output);
    return true;
}


```

Then I moved onto evaluatePostFixInput(). This was the most complex of the changes I had to make. 
I removed scanner and simply split it on my own by splitting it into an array of strings split at any
spaces, or " "s. After that, it was simple to go through the list, checking it's value, and converting it
to a double where needed. I also, of course, once again changed my exception types to be C# exceptions.

```java

/**
*  Evaluate an arithmetic expression written in postfix form.
*
*@param  input                         Postfix mathematical expression as a String
*@return                               Answer as a String
*@exception  IllegalArgumentException  Something went wrong
*/
public String evaluatePostFixInput( String input ) throws IllegalArgumentException
{
	if( input == null || input.equals("") )
		throw new IllegalArgumentException("Null or the empty string are not valid postfix expressions.");
	// Clear our stack before doing a new calculation
	stack.clear();

	String s;	// Temporary variable for token read
	double a;	// Temporary variable for operand
	double b;	// ...for operand
	double c;	// ...for answer

	Scanner st = new Scanner( input );
	while( st.hasNext() )
	{
		if( st.hasNextDouble() )
		{
			stack.push( new Double( st.nextDouble() ) );	// if it's a number push it on the stack
		}
		else
		{
			// Must be an operator or some other character or word.
			s = st.next();
			if( s.length() > 1 )
				throw new IllegalArgumentException("Input Error: " + s + " is not an allowed number or operator");
			// it may be an operator so pop two values off the stack and perform the indicated operation
			if( stack.isEmpty() )
				throw new IllegalArgumentException( "Improper input format. Stack became empty when expecting second operand." );
			b = ( (Double)( stack.pop() ) ).doubleValue();
			if( stack.isEmpty() )
				throw new IllegalArgumentException( "Improper input format. Stack became empty when expecting first operand." );
			a = ( (Double)( stack.pop() ) ).doubleValue();
			// Wrap up all operations in a single method, easy to add other binary operators this way if desired
			c = doOperation( a, b, s );
			// push the answer back on the stack
			stack.push( new Double( c ) );
		}
	}// End while
	return ( (Double)( stack.pop() ) ).toString();
}


```

Here it is after converting it into C#.

```c#
string EvaluatePostFixInput(string input)
{
    if(input == null || input == "")
    {
        throw new ArgumentException("Null or the empty string are not valid postfix expressions.");
    }
    stack.Clear();

    string s;
    double a;
    double b;
    double c;

    double test;

    string[] divided = input.Split(new char[0]);

    for(int i = 0; i < divided.Length; i++)
    {
        if (Double.TryParse(divided[i], out test))
        {
            stack.Push(Convert.ToDouble(divided[i]));
        }
        else
        {
            s = divided[i];
            if (stack.IsEmpty())
                throw new ArgumentException("Improper input format. Stack became empty when expecting second operand.");
            b = (Convert.ToDouble(stack.Pop()));
            if (stack.IsEmpty())
                throw new ArgumentException("Improper input format. Stack became empty when expecting first operand.");
            a = (Convert.ToDouble(stack.Pop()));
            c = DoOperation(a, b, s);

            stack.Push(Convert.ToDouble(c));
        }
    }
    return stack.Pop().ToString();
}
```

This is the last method in the calculator class, doOperation(). this was another easy change, mostly finding
the C# equivalent of things. A couple of string comparision changes and the changing of "NEGATIVE_INFINITY" and
"POSITIVE_INFINITY" to "NegativeInifinity" and "PositiveInfinity"

```java

		/**
		 *  Perform arithmetic.  Put it here so as not to clutter up the previous method, which is already pretty ugly.
		 *
		 *@param  a                             First operand
		 *@param  b                             Second operand
		 *@param  s                             operator
		 *@return                               The answer
		 *@exception  IllegalArgumentException  Something's fishy here
		 */
		public double doOperation( double a, double b, String s ) throws IllegalArgumentException
		{
			double c = 0.0;
			if( s.equals( "+" ) )		// Can't use a switch-case with Strings, so we do if-else
				c = ( a + b );
			else if( s.equals( "-" ) )
				c = ( a - b );
			else if( s.equals( "*" ) )
				c = ( a * b );
			else if( s.equals( "/" ) )
			{
				try
				{
					c = ( a / b );
					if( c == Double.NEGATIVE_INFINITY || c == Double.POSITIVE_INFINITY )
						throw new IllegalArgumentException("Can't divide by zero");
				}
				catch( ArithmeticException e ) 
				{
					throw new IllegalArgumentException(e.getMessage());
				}
			}
			else
				throw new IllegalArgumentException( "Improper operator: " + s + ", is not one of +, -, *, or /" );

			return c;
		}

	}// end class Calculator
}
```

Here it is in C#, which looks much cleaner in my personal opinion. 

```c#
        double DoOperation(double a, double b, string s)
        {
            double c = 0.0;
            if (s == "+")
                c = (a + b);
            else if (s == "-")
                c = (a - b);
            else if (s == "*")
                c = (a * b);
            else if (s == "/")
            {
                try
                {
                    c = (a / b);
                    if (c == double.NegativeInfinity || c == double.PositiveInfinity)
                        throw new ArgumentException("Can't divide by zero");
                }
                catch (ArithmeticException e)
                {
                    throw new ArgumentException(e.Message);
                }
            }
            else
                throw new ArgumentException("Improper operator: " + s + ", is not one of +, -, *, or / ");
            return c;
        }
    }
}

```

### Class 2

The second class I did was the StackADT. Now for consolidation's sake I'm including all of the Java code here
in one large block at the top. Since it is smaller than the previous class, it is feasable enough to
find everything you need in here. 

```java
/**
 * A singly linked stack implementation.
 */
public class LinkedStack implements StackADT
{
	private Node top;
	
	public LinkedStack()
	{
		top = null;	// Empty stack condition
	}
	
	public Object push(Object newItem)
	{
		if( newItem == null )
		{
			return null;
		}
		Node newNode = new Node(newItem,top);
		top = newNode;
		return newItem;
	}
	
	public Object pop()
	{
		if( isEmpty() )
		{
			return null;
		}
		Object topItem = top.data;
		top = top.next;
		return topItem;
	}
	
	public Object peek()
	{
		if( isEmpty() )
		{
			return null;
		}
		return top.data;
	}
	
	public boolean isEmpty()
	{
		return top == null;
	}
	
	public void clear()
	{
		top = null;
	}
	
}

```

Very little was changed in this method, as you can see. Changes in this class were made because of the changes
in Node class. 

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Calculator
{
    public class LinkedStack : IStackADT
    {
        private Node top;

        public LinkedStack()
        {
            top = null;
        }

        public object Push(object newItem)
        {
            if(newItem == null)
            {
                return null;
            }
            Node newNode = new Node(newItem, top);
            top = newNode;
            return newItem;
        }

        public object Pop()
        {
            if(IsEmpty())
            {
                return null;
            }
            object topItem = top.Data;
            top = top.Next;
            return topItem;
        }

        public object Peek()
        {
            if(IsEmpty())
            {
                return null;
            }
            return top.Data;
        }

        public bool IsEmpty()
        {
            return top == null;
        }

        public void Clear()
        {
            top = null;
        }


    }
}

```

### Class 3

I actually made quite a few changes in this class because I modified it to use properties. This was
pretty simple. Simply added some get and set methods. 

```java
/**
 * A simple singly linked node class.  This implementation comes from 
 * before Java had Generics.
 */
public class Node
{
	public Object data;	// The payload
	public Node next;	// Reference to the next Node in the chain
	
	public Node()
	{
		data = null;
		next = null;
	}
	
	public Node(Object data, Node next)
	{
		this.data = data;
		this.next = next;
	}
}
```

The C# code.

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Calculator
{
    public class Node
    {
        object data;
        Node next;

        public Node()
        {
            data = null;
            next = null;
        }

        public Node(object data, Node next)
        {
            this.data = data;
            this.next = next;
        }

        public object Data
        {
            get { return data; }
            set { data = value; }
        }

        public Node Next
        {
            get { return next; }
        }
    }
}


```
### Interface 1

Here's the Java interface before conversion to C#. However, I removed the comments to condense it for readability.

```java

/** Java Interface defining a Stack. */public interface StackADT{	public Object push(Object newItem);	public Object pop();		public Object peek();		public boolean isEmpty();		public void clear();}

```

Here it is after conversion.  Basically just removed the visibility modifiers here and added an "I" 
before the name.

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Calculator
{
    interface IStackADT
    {
        object Push(object newItem);
        object Pop();
        object Peek();
        bool IsEmpty();
        void Clear();
    }
}

```